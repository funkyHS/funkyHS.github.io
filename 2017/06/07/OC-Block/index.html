<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>OC-Block的使用 | Funky、</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="Welcome to Funky‘s zone. About me,so simple,Keep on coding,Keep on dancing. If you like something,stick to do！">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="OC-Block的使用 | Funky、">
    <meta name="twitter:description" content="Welcome to Funky‘s zone. About me,so simple,Keep on coding,Keep on dancing. If you like something,stick to do！">

    <meta property="og:type" content="article">
    <meta property="og:title" content="OC-Block的使用 | Funky、">
    <meta property="og:description" content="Welcome to Funky‘s zone. About me,so simple,Keep on coding,Keep on dancing. If you like something,stick to do！">

    
    <meta name="author" content="Husheng">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar.jpg">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Funky、" href="/atom.xml">
    

    <link rel="canonical" href="https://funkyhs.github.io/2017/06/07/OC-Block/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Funky、 的主页"><img src="/images/avatar.jpg" width="80" alt="Funky、 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Funky、">Funky、</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">Insist, Hard, Success</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">Welcome to Funky‘s zone. About me,so simple,Keep on coding,Keep on dancing. If you like something,stick to do！</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
              <li class="navigation__item"><a href="/tags/knowledge">关于技术</a></li>
            
              <li class="navigation__item"><a href="/tags/life">关于生活</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/3202571510/" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/funkyHS" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-06-07T13:12:21.000Z" class="post-list__meta--date date">2017-06-07</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/knowledge/">knowledge</a>
 </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">OC-Block的使用</h1>
  </header>

  <section class="post">
    <h2 id="Block的基础用法"><a href="#Block的基础用法" class="headerlink" title="Block的基础用法"></a>Block的基础用法</h2><h3 id="1-block作用"><a href="#1-block作用" class="headerlink" title="1 block作用"></a>1 block作用</h3><p>保存一段代码块</p>
<h3 id="2-block声明"><a href="#2-block声明" class="headerlink" title="2 block声明"></a>2 block声明</h3><pre><code>// 返回值(^block变量名)(参数)
void(^block)()

// block快捷方式 inline
返回值类型(^变量名)(参数类型) = ^(参数) {
     &lt;#statements#&gt;
};
</code></pre><h3 id="3-block定义（三种定义方式）"><a href="#3-block定义（三种定义方式）" class="headerlink" title="3 block定义（三种定义方式）"></a>3 block定义（三种定义方式）</h3><h4 id="3-1-格式：-参数"><a href="#3-1-格式：-参数" class="headerlink" title="3.1 格式： ^(参数){ }"></a>3.1 格式： ^(参数){ }</h4><pre><code>void(^block1)() = ^(){   

};
</code></pre><h4 id="3-2-如果没有参数，参数可以隐藏，如果有参数，定义的时候必须要写参数，而且要写参数的变量名"><a href="#3-2-如果没有参数，参数可以隐藏，如果有参数，定义的时候必须要写参数，而且要写参数的变量名" class="headerlink" title="3.2 如果没有参数，参数可以隐藏，如果有参数，定义的时候必须要写参数，而且要写参数的变量名"></a>3.2 如果没有参数，参数可以隐藏，如果有参数，定义的时候必须要写参数，而且要写参数的变量名</h4><pre><code>void(^block2)() = ^{

};
void(^block3)(int) = ^(int a){

};
</code></pre><h4 id="3-3-block的返回值可以省略，不管有没有返回值，都可以省略"><a href="#3-3-block的返回值可以省略，不管有没有返回值，都可以省略" class="headerlink" title="3.3 block的返回值可以省略，不管有没有返回值，都可以省略"></a>3.3 block的返回值可以省略，不管有没有返回值，都可以省略</h4><pre><code>int(^block4)() = ^int{
    return 3;
};
</code></pre><h3 id="4-block类型"><a href="#4-block类型" class="headerlink" title="4 block类型"></a>4 block类型</h3><pre><code>// block类型：int(^block5)(NSString *)
int(^block5)(NSString *) = ^(NSString *name){
    return 8;
};
</code></pre><h3 id="5-block调用"><a href="#5-block调用" class="headerlink" title="5 block调用"></a>5 block调用</h3><pre><code>// block类型：int(^block5)(NSString *)
int(^block5)(NSString *) = ^(NSString *name){
    return 8;
};
block5(@&quot;Funky&quot;);
</code></pre><hr>
<h2 id="Block变量传递"><a href="#Block变量传递" class="headerlink" title="Block变量传递"></a>Block变量传递</h2><ul>
<li><p>如果是局部变量 block 是值传递</p>
<pre><code>int a1 = 3;

void(^block1)() = ^{
    NSLog(@&quot;%d&quot;,a1); // 此时仍然输出3
};

a1 = 5;
block1();
</code></pre></li>
</ul>
<ul>
<li><p>如果是静态变量/全局变量/__block修饰的变量，block是指针传递</p>
<pre><code>static int a2 = 3;

void(^block2)() = ^{
    NSLog(@&quot;%d&quot;,a1); // 此时输出5
};

a2 = 5;
block2();
</code></pre></li>
</ul>
<hr>
<h2 id="Block使用场景"><a href="#Block使用场景" class="headerlink" title="Block使用场景"></a>Block使用场景</h2><h3 id="1-block保存代码"><a href="#1-block保存代码" class="headerlink" title="1. block保存代码"></a>1. block保存代码</h3><h4 id="1-1-在一个方法中定义，在另一个方法调用-（使用较少）"><a href="#1-1-在一个方法中定义，在另一个方法调用-（使用较少）" class="headerlink" title="1.1 在一个方法中定义，在另一个方法调用 （使用较少）"></a>1.1 在一个方法中定义，在另一个方法调用 （使用较少）</h4><p>首先我们定义一个block属性<br>方式一：</p>
<p>#import “ViewController.h”</p>
<pre><code>// BlockType :类型的别名
typedef void(^BlockType)();

@interface ViewController ()

@property (nonatomic,strong) BlockType block1;

@end
</code></pre><p>方式二：</p>
<pre><code>#import &quot;ViewController.h&quot;

@interface ViewController ()

// block怎么声明就怎么定义属性
@property (nonatomic,strong) void(^block)();

@end
</code></pre><p>然后保存代码，在其他方法中使用</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    void(^block)() = ^{
    NSLog(@&quot;调用block&quot;);
    };
    _block = block;

}
-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    _block();
}
</code></pre><h4 id="1-2-在一个类中定义在另外一个类中调用-（常用）"><a href="#1-2-在一个类中定义在另外一个类中调用-（常用）" class="headerlink" title="1.2 在一个类中定义在另外一个类中调用 （常用）"></a>1.2 在一个类中定义在另外一个类中调用 （常用）</h4><p>模仿个人中心的一些使用场景，具体的需求是：在不使用 if else 判断行的情况下，完成点击不同页面的跳转需求！页面我就简单模拟一下,具体写法的优点我就不说了，自己体会吧。。。<br><img src="http://or6lf2z6x.bkt.clouddn.com/image01.png" alt="案例-w100"></p>
<p>不扯淡，直接上代码。。。</p>
<p><strong>TableViewController.m文件</strong></p>
<pre><code>#import &quot;TableViewController.h&quot;
#import &quot;CellModel.h&quot;

@interface TableViewController ()

@property (nonatomic,strong) NSArray *dataArr;

@end

@implementation TableViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [self setupModel];
}

#pragma mark - 创建模型

-(void)setupModel {

    CellModel *model1 = [CellModel cellModelWithTitle:@&quot;我的收藏&quot;];
    model1.cellCallBack = ^{
    NSLog(@&quot;我的收藏&quot;);
    };

    CellModel *model2 = [CellModel cellModelWithTitle:@&quot;我的回复&quot;];
    model2.cellCallBack = ^{
    NSLog(@&quot;我的回复&quot;);
    };

    CellModel *model3 = [CellModel cellModelWithTitle:@&quot;我的订单&quot;];
    model3.cellCallBack = ^{
    NSLog(@&quot;我的订单&quot;);

    };

    _dataArr = @[model1,model2,model3];
}

#pragma mark - Table view data source


- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return self.dataArr.count;
}


- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {

    static NSString *cellId = @&quot;cellId&quot;;

    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellId];

    if (cell == nil) {
    cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellId];
    }

    CellModel *model = self.dataArr[indexPath.row];
    cell.textLabel.text = model.title;

    return cell;
}

-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{

    CellModel *model = self.dataArr[indexPath.row];
    model.cellCallBack ? model.cellCallBack():nil;
}


@end
</code></pre><p><strong>CellModel.h文件</strong></p>
<pre><code>@interface CellModel : NSObject

@property (nonatomic,strong) NSString *title;
// 定义一个block 用来保存代码
@property (nonatomic,strong) void(^cellCallBack)();

+(instancetype)cellModelWithTitle:(NSString *)title;

@end
</code></pre><p><strong>CellModel.m文件</strong></p>
<pre><code>@implementation CellModel

+(instancetype)cellModelWithTitle:(NSString *)title {

    CellModel *model = [[self alloc]init];
    model.title = title;
    return model;
}

@end
</code></pre><h3 id="2-block传值"><a href="#2-block传值" class="headerlink" title="2. block传值"></a>2. block传值</h3><ul>
<li>传值：（只要可以拿到对方就可以传值）</li>
<li>顺传：给需要传值的对象，直接定义属性就能传值</li>
<li>逆传：使用代理，block等</li>
</ul>
<p>场景： 点击vc1屏幕跳转至vc2  在vc2的textField上输入值，点击屏幕后回传给vc1<br>上代码<br><strong>CurrentViewController.m</strong></p>
<pre><code>-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{

    UIStoryboard *board = [UIStoryboard storyboardWithName: @&quot;Main&quot; bundle: nil];

    NextViewController *vc = [board instantiateViewControllerWithIdentifier: @&quot;NextViewController&quot;];
    vc.view.backgroundColor = [UIColor grayColor];
    vc.callBack = ^(NSString *inputStr){
        NSLog(@&quot;我收到了你的输入-----%@&quot;,inputStr);
    };

    [self presentViewController:vc animated:YES completion:nil];

}
</code></pre><p><strong>NextViewController.h</strong></p>
<pre><code>@property (nonatomic,strong) void(^callBack)(NSString *inputStr);
</code></pre><p><strong>NextViewController.m</strong></p>
<pre><code>-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    // textField 是拖出的控件
    self.callBack ? self.callBack(self.textField.text) : nil;
}
</code></pre><h3 id="3-block当参数使用"><a href="#3-block当参数使用" class="headerlink" title="3. block当参数使用"></a>3. block当参数使用</h3><p>什么时候需要把block当作参数使用：做的事情由外界决定，但是什么时候做由内部决定</p>
<p><strong>HttpTool.m</strong></p>
<pre><code>+(void)sendHttpRequestWithToken:(NSString *)token success:(void(^)(NSDictionary *dataDic))success {

    NSDictionary *responseData = @{@&quot;name&quot;:@&quot;Funky&quot;};
    if (success) {
        success(responseData);
    }
}
</code></pre><p>其他类中调用</p>
<pre><code>[HttpTool sendHttpRequestWithToken:@&quot;token&quot; success:^(NSDictionary *dataDic) {

    // 获得响应数据
    NSLog(@&quot;%@&quot;,dataDic);
}];
</code></pre><h3 id="4-block当作返回值使用（链式编程）"><a href="#4-block当作返回值使用（链式编程）" class="headerlink" title="4. block当作返回值使用（链式编程）"></a>4. block当作返回值使用（链式编程）</h3><p>场景：加法计算器<br><strong>CalculatorManager.m</strong></p>
<pre><code>-(CalculatorManager* (^)(int value))add {

    return ^(int value) {
        _result += value;

        return self;
    };
}
</code></pre><p><strong>CalculatorManager.h</strong></p>
<pre><code>@property (nonatomic,assign) int result;

-(CalculatorManager* (^)(int))add;
</code></pre><p>使用</p>
<pre><code>CalculatorManager *mgr = [[CalculatorManager alloc]init];
mgr.add(10).add(10);
</code></pre><p>具体的加法计算器在<a href="http://www.jianshu.com/p/87ef6720a096" target="_blank" rel="external">这篇文章</a>有具体的实现</p>
<hr>
<h2 id="Block内存管理"><a href="#Block内存管理" class="headerlink" title="Block内存管理"></a>Block内存管理</h2><p>block是不是对象？答案：是！官方文档显示如下<br><img src="/images/block/Snip20170604_1.png" alt=""></p>
<p>如何判断当前文件是MRC还是ARC？</p>
<ul>
<li>dealloc 能否调用super，只有MRC才能调用super</li>
<li>能否使用retain，release，如果能用就是MRC</li>
</ul>
<h3 id="1-MRC环境下"><a href="#1-MRC环境下" class="headerlink" title="1. MRC环境下"></a>1. MRC环境下</h3><p>MRC没有strong，weak，局部变量对象就是相当于基本数据类型<br>MRC给成员属性赋值，一定要使用 set 方法，不能直接访问下划线成员属性赋值</p>
<pre><code>int a = 3
void(^block)() = ^{
NSLog(@&quot;%d&quot;,a)
};
NSLog(@&quot;%@&quot;,block);
</code></pre><p>总结：</p>
<ul>
<li>只要block没有引用外部局部变量，block放在内存的全局区</li>
<li>只要block引用了外部的局部变量，block放在栈里面</li>
<li>block只能使用copy，不能使用retain，因为使用retain，block还是放在栈里面，出了方法会被释放，如何在其他地方调用，会crash</li>
</ul>
<h3 id="2-ARC环境下"><a href="#2-ARC环境下" class="headerlink" title="2. ARC环境下"></a>2. ARC环境下</h3><p>总结：</p>
<ul>
<li>只要block没有引用外部局部变量，block放在内存的全局区 (同MRC)</li>
<li>只要block引用了外部的局部变量，block放在堆里面 ，ARC环境下外部的局部变量默认都是强指针（不同于MRC）</li>
<li>block使用strong，最好不要使用copy</li>
</ul>
<hr>
<h2 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h2><p>循环引用：我引用你，你引用我，就会造成循环引用，双方都不会被销毁，导致内存泄漏问题<br><code>block造成循环引用：block会对里面所有强指针变量都强引用一次</code></p>
<p>假如在 NextViewController.m 文件中，我定义一个block属性</p>
<pre><code>@property(nonatomic,strong) void(^block)();
</code></pre><p>使用：</p>
<pre><code>/*
分析：
NextViewController的对象 有个block属性，指向了_block的内存
block对象 保存了一段代码！所以block对self这个外部对象变量进行了强引用
self的指针指向NextViewController的对象
self 对 block 强引用，block 又对 self 进行了强引用----&gt; 造成循环引用

*/
_block = ^{
    NSLog(@&quot;%@&quot;,self);   // 此时会造成循环引用
};
</code></pre><p>解决：将self变成弱指针变量,这样 block 就不会对 self 强引用</p>
<pre><code>__weak typeof(self) weakSelf = self;
_block = ^{
    NSLog(@&quot;%@&quot;,weakSelf);
};
_block();
</code></pre><p>假如工作中我们需要在 block 里面做耗时的请求操作，如果用 __weak 来修饰，会被释放，可能会出现问题<br>解决：</p>
<pre><code>__weak typeof(self) weakSelf = self;
_block = ^{        
    __strong typeof(weakSelf) strongSelf = weakSelf;

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@&quot;%@&quot;,strongSelf);
    });

};

_block();
</code></pre><p>理解：</p>
<ul>
<li>NextViewController对象有一个block属性，指向了 _block对象 —&gt; self 对block 强引用</li>
<li>_block 内部使用了 weakSelf 弱指针变量 ——&gt; block对self弱引用</li>
<li>__strong typeof(weakSelf) strongSelf 是一个局部变量指针，它在一个新的栈里面，它是一个强指针，指向NextViewController对象</li>
<li>dispatch_after 是由系统管理的block，在这个block中 强引用了strongSelf，strongSelf又指向NextViewController对象<br>dispatch_after这个block会在10秒以后，系统会自动销毁</li>
<li>调用_block,当执行完代码块，strongSelf这个指针会没有了，但是NextViewController对象不会被销毁，因为dispatch_after里面的strongSelf强引用着，当10秒以后dispatch_after block会被销毁，那strongSelf强引用就没有了，此时NextViewController对象就会被销毁，执行dealloc方法</li>
</ul>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/06/18/OC-触摸事件-响应者链条/" title="OC-触摸事件&amp;响应者链条">OC-触摸事件&amp;响应者链条</a></h2>
                <p class="excerpt">
                
                iOS中的事件
在用户使用app过程中，会产生各种各样的事件，iOS中的事件可以分为3大类型：触摸事件，加速计事件，远程控制事件

响应者对象
在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件。我们称之为响应者对象
UIApplication、UIView
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-06-18T07:55:35.000Z" class="post-list__meta--date date">2017-06-18</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/knowledge/">knowledge</a>
</span><a class="btn-border-small" href="/2017/06/18/OC-触摸事件-响应者链条/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/06/07/吐槽/" title="吐槽">吐槽</a></h2>
                <p class="excerpt">
                
                博客搭建有一段时间了，一直没有写文章，是因为遇到坑了我写的文章保存在为知笔记里，想往博客上传，于是，全选，复制，粘贴，一顿很愉快的操作！就准备发博客了，于是遇到了问题，问题如下：123456789101112131415161718192021222324hushengdeMacBook-Pro:b
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-06-07T12:54:37.000Z" class="post-list__meta--date date">2017-06-07</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/knowledge/">knowledge</a>
</span><a class="btn-border-small" href="/2017/06/07/吐槽/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  
<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'funkyhs'; 
      
  var disqus_identifier = '/2017/06/07/OC-Block/';
  var disqus_title = 'OC-Block的使用';
  var disqus_url = 'https://funkyhs.github.io/2017/06/07/OC-Block/';
  

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          //dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          dsq.src = 'https://a.disquscdn.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


            <footer class="footer">
    <span class="footer__copyright">
        本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2017 - 本站使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题,
        由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
    </span>
    
</footer>


        </div>
    </div>

     
    


    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
